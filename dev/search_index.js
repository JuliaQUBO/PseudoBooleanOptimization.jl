var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Variables","page":"API Reference","title":"Variables","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"PBO.varlt\nPBO.varmul\nPBO.varmap\nPBO.vargen\nPBO.varshow","category":"page"},{"location":"api/#PseudoBooleanOptimization.varlt","page":"API Reference","title":"PseudoBooleanOptimization.varlt","text":"varlt(u::V, v::V) where {V}\n\nCompares two variables, u and v, with respect to their length-lexicographic order.\n\nRationale\n\nThis function exists to define an arbitrary ordering for a given type and was created to address [MOI]. There is no predefined comparison between instances MOI's VariableIndex type.\n\n[^MOI]: MathOptInterface Issue [#1985](https://github.com/jump-dev/MathOptInterface.jl/issues/1985)\n\n\n\n\n\n","category":"function"},{"location":"api/#PseudoBooleanOptimization.varmul","page":"API Reference","title":"PseudoBooleanOptimization.varmul","text":"varmul(u::V, v::V) where {V}\n\n\n\n\n\n","category":"function"},{"location":"api/#PseudoBooleanOptimization.varmap","page":"API Reference","title":"PseudoBooleanOptimization.varmap","text":"varmap(::Type{V}, i::Integer) where {V}\n\n\n\n\n\n","category":"function"},{"location":"api/#PseudoBooleanOptimization.vargen","page":"API Reference","title":"PseudoBooleanOptimization.vargen","text":"vargen(::AbstractPBF{V,T}; name::AbstractString = \"x\") where {V<:AbstractString,T}\n\nCreates a function that, when called multiple times, returns the strings \"aux_1\", \"aux_2\", ... and so on.\n\nvargen(::AbstractPBF{Symbol,T}; name::Symbol = :x) where {T}\n\nCreates a function that, when called multiple times, returns the symbols :x₋₁, :x₋₂, ... and so on.\n\nvargen(::AbstractPBF{V,T}; start::V = V(0), step::V = V(-1)) where {V<:Integer,T}\n\nCreates a function that, when called multiple times, returns the integers -1, -2, ... and so on.\n\n\n\n\n\n","category":"function"},{"location":"api/#PseudoBooleanOptimization.varshow","page":"API Reference","title":"PseudoBooleanOptimization.varshow","text":"varshow(v::V) where {V}\nvarshow(io::IO, v::V) where {V}\n\n\n\n\n\n","category":"function"},{"location":"api/#Terms","page":"API Reference","title":"Terms","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"PBO.AbstractTerm\nPBO.Term\nPBO.term\nPBO.term_head\nPBO.term_tail","category":"page"},{"location":"api/#PseudoBooleanOptimization.AbstractTerm","page":"API Reference","title":"PseudoBooleanOptimization.AbstractTerm","text":"AbstractTerm{V}\n\n\n\n\n\n","category":"type"},{"location":"api/#PseudoBooleanOptimization.Term","page":"API Reference","title":"PseudoBooleanOptimization.Term","text":"Term{V}\n\nReference implementation for AbstractTerm.\n\n\n\n\n\n","category":"type"},{"location":"api/#PseudoBooleanOptimization.term","page":"API Reference","title":"PseudoBooleanOptimization.term","text":"term\n\n\n\n\n\n","category":"function"},{"location":"api/#PseudoBooleanOptimization.term_head","page":"API Reference","title":"PseudoBooleanOptimization.term_head","text":"term_head\n\n\n\n\n\n","category":"function"},{"location":"api/#PseudoBooleanOptimization.term_tail","page":"API Reference","title":"PseudoBooleanOptimization.term_tail","text":"term_tail\n\n\n\n\n\n","category":"function"},{"location":"api/#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"PBO.AbstractPBF\nPBO.PBF\nPBO.data","category":"page"},{"location":"api/#PseudoBooleanOptimization.AbstractPBF","page":"API Reference","title":"PseudoBooleanOptimization.AbstractPBF","text":"AbstractPBF{V,T}\n\nA pseudo-Boolean Function[Boros2002] f in mathscrF over some field mathbbT takes the form\n\nf(mathbfx) = sum_omega in Omegaleftfright c_omega prod_j in omega x_j\n\nwhere each Omegaleftfright is the multi-linear representation of f as a set of terms. Each term is given by a unique set of indices omega subseteq mathbbV related to some coefficient c_omega in mathbbT. We say that omega in Omegaleftfright iff c_omega neq 0. Variables x_j are boolean, thus f  mathbbB^n to mathbbT.\n\n[Boros2002]: Endre Boros, Peter L. Hammer, Pseudo-Boolean optimization, Discrete Applied Mathematics, 2002 {doi}\n\n\n\n\n\n","category":"type"},{"location":"api/#PseudoBooleanOptimization.PBF","page":"API Reference","title":"PseudoBooleanOptimization.PBF","text":"PBF{V,T,S}\n\nThis is a concrete implementation of AbstractPBF that uses the S data structure to store the terms of the function.\n\n\n\n\n\n","category":"type"},{"location":"api/#PseudoBooleanOptimization.data","page":"API Reference","title":"PseudoBooleanOptimization.data","text":"data(f::AbstractPBF{V,T})\n\nReturns the internal representation of f in mathscrF.\n\n\n\n\n\n","category":"function"},{"location":"api/#Analysis","page":"API Reference","title":"Analysis","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"PBO.isconstant\nPBO.degree","category":"page"},{"location":"api/#PseudoBooleanOptimization.isconstant","page":"API Reference","title":"PseudoBooleanOptimization.isconstant","text":"isconstant(f::AbstractPBF)::Bool\n\nCheck if the given Pseudo-Boolean function f is a constant, i.e., if it has no variables.\n\n\n\n\n\n","category":"function"},{"location":"api/#PseudoBooleanOptimization.degree","page":"API Reference","title":"PseudoBooleanOptimization.degree","text":"degree(f::AbstractPBF)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"PBO.lowerbound\nPBO.upperbound\nPBO.bounds\nPBO.mingap\nPBO.maxgap","category":"page"},{"location":"api/#PseudoBooleanOptimization.lowerbound","page":"API Reference","title":"PseudoBooleanOptimization.lowerbound","text":"lowerbound(f::AbstractPBF)\n\nComputes an approximate value for the greatest forall mathbfx l le f(mathbfx).\n\n\n\n\n\n","category":"function"},{"location":"api/#PseudoBooleanOptimization.upperbound","page":"API Reference","title":"PseudoBooleanOptimization.upperbound","text":"upperbound(f::AbstractPBF)\n\nComputes an approximate value for the least forall mathbfx u ge f(mathbfx).\n\n\n\n\n\n","category":"function"},{"location":"api/#PseudoBooleanOptimization.bounds","page":"API Reference","title":"PseudoBooleanOptimization.bounds","text":"bounds(f::AbstractPBF)\n\nGiven f  mathbbB^n to a b, returns the approximate extrema for the tightest l u supset a b.\n\n\n\n\n\n","category":"function"},{"location":"api/#PseudoBooleanOptimization.mingap","page":"API Reference","title":"PseudoBooleanOptimization.mingap","text":"mingap(f::AbstractPBF{V,T}, tol::T = T(1e-6)) where {V,T}\n\nThe ideal minimum gap is the greatest lower bound on the smallest non-zero value taken by f in mathscrF.\n\n\n\n\n\n","category":"function"},{"location":"api/#PseudoBooleanOptimization.maxgap","page":"API Reference","title":"PseudoBooleanOptimization.maxgap","text":"maxgap(f::AbstractPBF{V,T}) where {V,T}\n\nComputes the least upper bound for the greatest variantion possible of f in mathscrF i. e.\n\nbeginarrayrl\n    min         M \n    textst  leftf(mathbfx) - f(mathbfy)right le M  forall mathbfx mathbfy in mathbbB^n \nendarray\n\nA simple approach is to define\n\nM triangleq sum_omega neq varnothing leftc_omegaright\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"PBO.derivative\nPBO.gradient\nPBO.residual","category":"page"},{"location":"api/#PseudoBooleanOptimization.derivative","page":"API Reference","title":"PseudoBooleanOptimization.derivative","text":"derivative(f::AbstractPBF{V,T}, x::V) where {V,T}\n\nThe partial derivate of function f in mathscrF with respect to the x variable.\n\n    Delta_i f(mathbfx) = fracpartial f(mathbfx)partial mathbfx_i =\n    sum_omega in Omegaleftfright setminus leftiright\n    c_omega cup leftiright prod_k in omega mathbfx_k\n\n\n\n\n\n","category":"function"},{"location":"api/#PseudoBooleanOptimization.gradient","page":"API Reference","title":"PseudoBooleanOptimization.gradient","text":"gradient(f::AbstractPBF)\n\nComputes the gradient of f in mathscrF where the i-th derivative is given by derivative.\n\n\n\n\n\n","category":"function"},{"location":"api/#PseudoBooleanOptimization.residual","page":"API Reference","title":"PseudoBooleanOptimization.residual","text":"residual(f::AbstractPBF{V,T}, x::S) where {V,T}\n\nThe residual of f in mathscrF with respect to x.\n\n    Theta_i f(mathbfx) = f(mathbfx) - mathbfx_i Delta_i f(mathbfx) =\n    sum_omega in Omegaleftfright setminus leftiright\n    c_omega prod_k in omega mathbfx_k\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"PBO.discretize\nPBO.discretize!","category":"page"},{"location":"api/#PseudoBooleanOptimization.discretize","page":"API Reference","title":"PseudoBooleanOptimization.discretize","text":"discretize(f::AbstractPBF{V,T}; tol::T) where {V,T}\n\nFor a given function f in mathscrF written as\n\n    fleft(mathbfxright) = sum_omega in Omegaleftfright c_omega prod_i in omega mathbfx_i\n\ncomputes an approximate function  g  mathbbB^n to mathbbZ such that\n\n    textargmin_mathbfx in mathbbB^n gleft(mathbfxright) = textargmin_mathbfx in mathbbB^n fleft(mathbfxright)\n\nThis is done by rationalizing every coefficient c_omega according to some tolerance tol.\n\n\n\n\n\n","category":"function"},{"location":"api/#PseudoBooleanOptimization.discretize!","page":"API Reference","title":"PseudoBooleanOptimization.discretize!","text":"discretize!(f::AbstractPBF{V,T}; tol::T) where {V,T}\n\nIn-place version of discretize.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"PBO.relaxedgcd","category":"page"},{"location":"api/#PseudoBooleanOptimization.relaxedgcd","page":"API Reference","title":"PseudoBooleanOptimization.relaxedgcd","text":"relaxedgcd(x::T, y::T; tol::T = T(1E-6)) where {T}\n\nWe define two real numbers x and y to be tau-comensurable if, for some tau  0 there exists a continued fractions convergent p_k div q_k such that\n\n    left q_k x - p_k y right le tau\n\n\n\n\n\n","category":"function"},{"location":"api/#Quadratization","page":"API Reference","title":"Quadratization","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"PBO.quadratize\nPBO.quadratize!\nPBO.infer_quadratization","category":"page"},{"location":"api/#PseudoBooleanOptimization.quadratize","page":"API Reference","title":"PseudoBooleanOptimization.quadratize","text":"quadratize(aux, f::PBF{V, T}, ::Quadratization{Q}) where {V,T,Q}\n\nQuadratizes a given PBF, i.e., applies a mapping mathcalQ  mathscrF^k to mathscrF^2, where mathcalQ is the quadratization method.\n\nAuxiliary variables\n\nThe aux function is expected to produce auxiliary variables with the following signatures:\n\naux()::V where {V}\n\nCreates and returns a single variable.\n\naux(n::Integer)::Vector{V} where {V}\n\nCreates and returns a vector with n variables.\n\nquadratize(f::PBF{V, T}, ::Quadratization{Q}) where {V,T,Q}\n\nWhen aux is not specified, uses vargen to generate variables.\n\n\n\n\n\n","category":"function"},{"location":"api/#PseudoBooleanOptimization.quadratize!","page":"API Reference","title":"PseudoBooleanOptimization.quadratize!","text":"quadratize!(aux, f::PBF{V, T}, ::Quadratization{Q}) where {V,T,Q}\nquadratize!(f::PBF{V, T}, ::Quadratization{Q}) where {V,T,Q}\n\nIn-place version of quadratize.\n\n\n\n\n\n","category":"function"},{"location":"api/#PseudoBooleanOptimization.infer_quadratization","page":"API Reference","title":"PseudoBooleanOptimization.infer_quadratization","text":"infer_quadratization(f::AbstractPBF)\n\nFor a given PBF, returns whether it should be quadratized or not, based on its degree.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"PBO.PTR_BG\nPBO.NTR_KZFD\nPBO.DEFAULT","category":"page"},{"location":"api/#PseudoBooleanOptimization.PTR_BG","page":"API Reference","title":"PseudoBooleanOptimization.PTR_BG","text":"Quadratization(::PTR_BG; stable::Bool = false)\n\nPositive term reduction PTR-BG[PTR_BG]\n\nLet f(mathbfx) = x_1 x_2 dots x_k.\n\nmathcalQleftlbracefrightrbrace(mathbfx mathbfw) = left\n    sum_i = 1^k-2 z_i left( k - i - 1 + x_i - sum_j = i+1^k x_j right)\nright + x_k-1 x_k\n\nwhere mathbfx in mathbbB^k and mathbfw in mathbbB^k-2\n\nProperties\n\nVariables Non-submodular Terms\nk - 2 k - 1\n\n[PTR_BG]:     Boros & Gruber, 2014\n\n\n\n\n\n","category":"type"},{"location":"api/#PseudoBooleanOptimization.NTR_KZFD","page":"API Reference","title":"PseudoBooleanOptimization.NTR_KZFD","text":"Quadratization(::NTR_KZFD; stable::Bool = false)\n\nNegative term reduction NTR-KZFD[NTR_KZFD]\n\nLet f(mathbfx) = -x_1 x_2 dots x_k.\n\nmathcalQleftlbracefrightrbrace(mathbfx w) = (k - 1) w - sum_i = 1^k x_i w\n\nwhere mathbfx in mathbbB^k w in mathbbB.\n\nProperties\n\nVariables Non-submodular Terms\n1 0\n\ninfo: Info\nNTR-KZFD is only applicable to negative terms.\n\ninfo: Info\nThis method is stable by construction.\n\n[NTR_KZFD]: Kolmogorov & Zabih, 2004; Freedman & Drineas, 2005\n\n\n\n\n\n","category":"type"},{"location":"api/#PseudoBooleanOptimization.DEFAULT","page":"API Reference","title":"PseudoBooleanOptimization.DEFAULT","text":"Quadratization(::DEFAULT; stable::Bool = false)\n\nEmploys NTR_KZFD for negative terms and PTR_BG for the positive ones.\n\n\n\n\n\n","category":"type"},{"location":"api/#Synthesis","page":"API Reference","title":"Synthesis","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"PBO.wishart\nPBO.sherrington_kirkpatrick\nPBO.not_all_equal_3sat\nPBO.k_regular_k_xorsat\nPBO.r_regular_k_xorsat","category":"page"},{"location":"api/#PseudoBooleanOptimization.wishart","page":"API Reference","title":"PseudoBooleanOptimization.wishart","text":"wishart(rng, n::Integer, m::Integer)\n\nGenerate a K_n (complete graph) Ising weight matrix J with the mathbf1 in pm 1^n state as a planted ground state.\n\nThe main diagonal of J is zero.\n\nThe Hamiltonian is zero field, i.e,\n\nE(mathbfs) = -frac12 mathbfs J mathbfs\n\nm specifies the number of columns in W (for m ge n, FM and easy.)\nprecision: number of decimal points to round the uncorrelated Gaussian used to generate the w elements. This is to avoid numerical issues where a spurious state takes over as the GS.\n\nAlternatively, can even replace the Gaussian with a bounded range uniform discrete distribution in -range +range...\n\n\n\n\n\n","category":"function"},{"location":"api/#PseudoBooleanOptimization.sherrington_kirkpatrick","page":"API Reference","title":"PseudoBooleanOptimization.sherrington_kirkpatrick","text":"sherrington_kirkpatrick(rng, ::Type{F}, n::Integer; μ::T = zero(T), σ::T = one(T)) where {V,T,F<:AbstractPBF{V,T}}\n\nf^(n)_textrmSK(mathbfx) = sum_i = 1^n sum_j = i + 1^n J_i j x_i x_j\n\nwhere J_i j sim mathcalN(0 1).\n\n\n\n\n\n","category":"function"},{"location":"api/#PseudoBooleanOptimization.not_all_equal_3sat","page":"API Reference","title":"PseudoBooleanOptimization.not_all_equal_3sat","text":"not_all_equal_3sat(rng, n::Integer, m::Integer)\n\nGenerates Not-all-equal 3-SAT problem with m variables and n clauses.\n\n\n\n\n\n","category":"function"},{"location":"api/#PseudoBooleanOptimization.k_regular_k_xorsat","page":"API Reference","title":"PseudoBooleanOptimization.k_regular_k_xorsat","text":"k_regular_k_xorsat\n\nGenerates a k-regurlar k-XORSAT instance with n boolean variables.\n\n\n\n\n\n","category":"function"},{"location":"api/#PseudoBooleanOptimization.r_regular_k_xorsat","page":"API Reference","title":"PseudoBooleanOptimization.r_regular_k_xorsat","text":"r_regular_k_xorsat(rng, r::Integer, k::Integer; quad::QuadratizationMethod)\n\nGenerates a r-regurlar k-XORSAT instance with n boolean variables.\n\nIf r = k, then falls back to k_regular_k_xorsat.\n\n\n\n\n\n","category":"function"},{"location":"manual/3-operators/#Operations-with-pseudo-Boolean-functions","page":"Operations with pseudo-Boolean functions","title":"Operations with pseudo-Boolean functions","text":"","category":"section"},{"location":"manual/3-operators/#Arithmetic-operations","page":"Operations with pseudo-Boolean functions","title":"Arithmetic operations","text":"","category":"section"},{"location":"manual/3-operators/","page":"Operations with pseudo-Boolean functions","title":"Operations with pseudo-Boolean functions","text":"The arithmetic operations +, -, *, /, ^ are defined for pseudo-Boolean functions. The result of an arithmetic operation is a pseudo-Boolean function.","category":"page"},{"location":"manual/4-quadratization/#Quadratization","page":"Quadratization","title":"Quadratization","text":"","category":"section"},{"location":"manual/4-quadratization/","page":"Quadratization","title":"Quadratization","text":"A Quadratization is a mapping mathcalQf mathsrcF to mathsrcF^2 such that","category":"page"},{"location":"manual/4-quadratization/","page":"Quadratization","title":"Quadratization","text":"min_mathbfy mathsrcQf(mathbfx mathbfy) = f(mathbfx) forall mathbfx in mathbbB^nforall f in mathsrcF","category":"page"},{"location":"manual/2-function/#Pseudo-Boolean-functions","page":"Pseudo-Boolean functions","title":"Pseudo-Boolean functions","text":"","category":"section"},{"location":"manual/2-function/","page":"Pseudo-Boolean functions","title":"Pseudo-Boolean functions","text":"Let f: \\mathbb{B}^{n} \\to \\mathbb{R}. Then f can be written as","category":"page"},{"location":"manual/2-function/","page":"Pseudo-Boolean functions","title":"Pseudo-Boolean functions","text":"f(mathbfx) = sum_omega subseteq n c_omega prod_j in omega x_j","category":"page"},{"location":"manual/2-function/","page":"Pseudo-Boolean functions","title":"Pseudo-Boolean functions","text":"where c_omega in mathbbR and x_j in  0 1  for all j in n =  1 dots n .","category":"page"},{"location":"manual/5-synthesis/#Synthetic-Problem-Generation","page":"Synthetic Problem Generation","title":"Synthetic Problem Generation","text":"","category":"section"},{"location":"manual/5-synthesis/","page":"Synthetic Problem Generation","title":"Synthetic Problem Generation","text":"import PseudoBooleanOptimization as PBO\n\nf = PBO.wishart(PBO.PBF{Int,Float64}, 3, 5)","category":"page"},{"location":"#PseudoBooleanOptimization.jl","page":"Home","title":"PseudoBooleanOptimization.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"f(mathbfx) = sum_omega subseteq n c_omega prod_j in omega x_j","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"import PseudoBooleanOptimization as PBO\n\nf = PBO.PBF{Symbol,Float64}(\n    :x       => 3.0,\n    (:y, :z) => 4.0,\n    (:x, :w) => 1.0,\n    -100.0,\n)\n\ng = f^2 - 2f","category":"page"},{"location":"#Table-of-Contents","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"manual/1-intro.md\",\n    \"manual/2-function.md\",\n    \"manual/3-operators.md\",\n    \"manual/4-quadratization.md\",\n]\nDepth = 2","category":"page"},{"location":"manual/1-intro/#PseudoBooleanOptimization.jl-Manual","page":"PseudoBooleanOptimization.jl Manual","title":"PseudoBooleanOptimization.jl Manual","text":"","category":"section"},{"location":"manual/1-intro/#Introduction","page":"PseudoBooleanOptimization.jl Manual","title":"Introduction","text":"","category":"section"},{"location":"assets/README/#PseudoBooleanOptimization.jl's-Assets","page":"PseudoBooleanOptimization.jl's Assets","title":"PseudoBooleanOptimization.jl's Assets","text":"","category":"section"},{"location":"assets/README/#logo","page":"PseudoBooleanOptimization.jl's Assets","title":"Logo","text":"","category":"section"},{"location":"assets/README/","page":"PseudoBooleanOptimization.jl's Assets","title":"PseudoBooleanOptimization.jl's Assets","text":"PseudoBooleanOptimization's logo is yet to be designed.","category":"page"},{"location":"assets/README/","page":"PseudoBooleanOptimization.jl's Assets","title":"PseudoBooleanOptimization.jl's Assets","text":"(Image: PseudoBooleanOptimization.jl)","category":"page"},{"location":"assets/README/#Colors","page":"PseudoBooleanOptimization.jl's Assets","title":"Colors","text":"","category":"section"},{"location":"assets/README/","page":"PseudoBooleanOptimization.jl's Assets","title":"PseudoBooleanOptimization.jl's Assets","text":"The colors were chosen according to Julia's Reference for logo graphics[Julia]. Text color matches renders fairly well in both light and dark background themes.","category":"page"},{"location":"assets/README/#Typography","page":"PseudoBooleanOptimization.jl's Assets","title":"Typography","text":"","category":"section"},{"location":"assets/README/","page":"PseudoBooleanOptimization.jl's Assets","title":"PseudoBooleanOptimization.jl's Assets","text":"The MADETYPE Sunflower[Sunflower] font was chosen. It was converted to a SVG path using the Google Font to Svg Path[DanMarshall] online tool.","category":"page"},{"location":"assets/README/","page":"PseudoBooleanOptimization.jl's Assets","title":"PseudoBooleanOptimization.jl's Assets","text":"[Julia]: github.com/JuliaLang/julia-logo-graphics","category":"page"},{"location":"assets/README/","page":"PseudoBooleanOptimization.jl's Assets","title":"PseudoBooleanOptimization.jl's Assets","text":"[Sunflower]: Licensed by the authors for use in this project","category":"page"},{"location":"assets/README/","page":"PseudoBooleanOptimization.jl's Assets","title":"PseudoBooleanOptimization.jl's Assets","text":"[DanMarshall]: danmarshall.github.io/google-font-to-svg-path","category":"page"}]
}
